// Simplified job queue for video upload pipeline (no Supabase)
// Each job: download ‚Üí compress ‚Üí upload to TeraBox
// Only ONE job processes at a time (downloading, compressing, or uploading)

export type SimpleJobStatus =
  | 'queued'
  | 'downloading'
  | 'compressing'
  | 'uploading'
  | 'done'
  | 'error';

export interface SimpleJobProgress {
  percentage: number; // 0-100
  sizeMB?: number; // Current size
  totalMB?: number; // Total size (for downloads)
  message?: string; // Current activity message
}

export interface SimpleJob {
  id: string;
  sourceUrl: string;
  status: SimpleJobStatus;
  progress?: SimpleJobProgress;
  teraboxFileId?: string; // Result: terabox://[fileId]
  error?: string;
  createdAt: number;
  startedAt?: number;
  completedAt?: number;
}

const jobs = new Map<string, SimpleJob>();
const queue: string[] = [];
let isProcessing = false;
let statusInterval: NodeJS.Timeout | null = null;

export function enqueueSimpleJob(sourceUrl: string): string {
  const id = `sjob_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
  const job: SimpleJob = {
    id,
    sourceUrl,
    status: 'queued',
    createdAt: Date.now(),
  };
  jobs.set(id, job);
  queue.push(id);

  startStatusLogger();
  processQueue();
  return id;
}

export function getAllSimpleJobs(): SimpleJob[] {
  return Array.from(jobs.values()).sort((a, b) => b.createdAt - a.createdAt);
}

export function getQueueStatus() {
  const allJobs = getAllSimpleJobs();
  const queued = allJobs.filter((j) => j.status === 'queued');
  const downloading = allJobs.filter((j) => j.status === 'downloading');
  const compressing = allJobs.filter((j) => j.status === 'compressing');
  const uploading = allJobs.filter((j) => j.status === 'uploading');
  const done = allJobs.filter((j) => j.status === 'done');
  const error = allJobs.filter((j) => j.status === 'error');

  return {
    queued: queued.length,
    downloading: downloading[0] || null,
    compressing: compressing[0] || null,
    uploading: uploading[0] || null,
    done: done.length,
    error: error.length,
    total: allJobs.length,
  };
}

function startStatusLogger() {
  if (statusInterval) return;
  
  statusInterval = setInterval(() => {
    const status = getQueueStatus();
    
    // Clear console and print status
    process.stdout.write('\x1Bc'); // Clear console
    console.log('üìä ÏûëÏóÖ ÏÉÅÌÉú');
    console.log('‚îÄ'.repeat(40));
    console.log(`ÎåÄÍ∏∞: ${status.queued}`);
    
    if (status.downloading) {
      const prog = status.downloading.progress;
      const percent = prog ? `${prog.percentage.toFixed(0)}%` : '0%';
      console.log(`Îã§Ïö¥Î°úÎìú: ${percent}`);
    } else {
      console.log(`Îã§Ïö¥Î°úÎìú: -`);
    }
    
    if (status.compressing) {
      const prog = status.compressing.progress;
      const percent = prog ? `${prog.percentage.toFixed(0)}%` : '0%';
      console.log(`ÏïïÏ∂ï: ${percent}`);
    } else {
      console.log(`ÏïïÏ∂ï: -`);
    }
    
    if (status.uploading) {
      const prog = status.uploading.progress;
      const percent = prog ? `${prog.percentage.toFixed(0)}%` : '0%';
      console.log(`ÏóÖÎ°úÎìú: ${percent}`);
    } else {
      console.log(`ÏóÖÎ°úÎìú: -`);
    }
    
    console.log('‚îÄ'.repeat(40));
    console.log(`‚úÖ ÏôÑÎ£å: ${status.done}  ‚ùå Ïã§Ìå®: ${status.error}`);
    
    // Stop if no active jobs
    if (!status.downloading && !status.compressing && !status.uploading && status.queued === 0) {
      stopStatusLogger();
    }
  }, 1000);
}

function stopStatusLogger() {
  if (statusInterval) {
    clearInterval(statusInterval);
    statusInterval = null;
  }
}

// Update job progress and log status
export function updateSimpleJobProgress(
  jobId: string,
  progress: SimpleJobProgress
) {
  const job = jobs.get(jobId);
  if (job) {
    job.progress = progress;
    // Log every 5% progress or status change
    if (
      !job.progress ||
      Math.abs(progress.percentage - (job.progress?.percentage || 0)) >= 5
    ) {
      logQueueStatus();
    }
  }
}

async function processQueue() {
  if (isProcessing || queue.length === 0) {
    return;
  }

  const jobId = queue.shift();
  if (!jobId) return;

  const job = jobs.get(jobId);
  if (!job) {
    console.error(`[Queue] ‚ùå Job ${jobId} not found`);
    return;
  }

  isProcessing = true;
  console.log(`\nüöÄ [Queue] Starting job: ${jobId}`);
  console.log(`üìã [Queue] Source URL: ${job.sourceUrl}`);

  try {
    await processSimpleJob(job);
    console.log(`‚úÖ [Queue] Job ${jobId} completed successfully`);
  } catch (e) {
    console.error(`‚ùå [Queue] Job ${jobId} failed:`, e);
    job.status = 'error';
    job.error = String(e);
    job.completedAt = Date.now();
  } finally {
    isProcessing = false;
    logQueueStatus();

    if (queue.length > 0) {
      console.log(
        `‚è≠Ô∏è  [Queue] ${queue.length} jobs remaining, processing next...`
      );
      processQueue(); // Process next job
    } else {
      console.log(`üí§ [Queue] All jobs completed, queue is empty`);
    }
  }
}

async function processSimpleJob(job: SimpleJob) {
  job.startedAt = Date.now();

  try {
    // 1. Download
    console.log(`\n‚¨áÔ∏è  [Job ${job.id}] Step 1/3: Downloading video...`);
    job.status = 'downloading';
    job.progress = { percentage: 0, message: 'Îã§Ïö¥Î°úÎìú ÏãúÏûë...' };
    logQueueStatus();

    const { downloadVideo } = await import('./videoDownloader');
    const downloadPath = await downloadVideo(
      job.sourceUrl,
      job.id,
      (percent, downloadedMB, totalMB) => {
        updateSimpleJobProgress(job.id, {
          percentage: percent,
          sizeMB: downloadedMB,
          totalMB,
          message: `Îã§Ïö¥Î°úÎìú: ${percent.toFixed(1)}%`,
        });
      }
    );
    console.log(`‚úÖ [Job ${job.id}] Downloaded to: ${downloadPath}`);

    // 2. Compress
    console.log(`\nüîÑ [Job ${job.id}] Step 2/3: Compressing video...`);
    job.status = 'compressing';
    job.progress = { percentage: 0, message: 'ÏïïÏ∂ï ÏãúÏûë...' };
    logQueueStatus();

    const { compressVideo } = await import('./videoCompressor');
    const compressedPath = await compressVideo(
      downloadPath,
      job.id,
      async (percent) => {
        // Get file size if file exists
        try {
          const fs = await import('fs');
          const stats = fs.statSync(compressedPath);
          const sizeMB = stats.size / (1024 * 1024);

          updateSimpleJobProgress(job.id, {
            percentage: percent,
            sizeMB,
            message: `ÏïïÏ∂ï: ${percent.toFixed(1)}%`,
          });
        } catch {
          // File may not exist yet
          updateSimpleJobProgress(job.id, {
            percentage: percent,
            message: `ÏïïÏ∂ï: ${percent.toFixed(1)}%`,
          });
        }
      }
    );
    console.log(`‚úÖ [Job ${job.id}] Compressed to: ${compressedPath}`);

    // 3. Upload to TeraBox
    console.log(`\n‚¨ÜÔ∏è  [Job ${job.id}] Step 3/3: Uploading to TeraBox...`);
    job.status = 'uploading';
    job.progress = { percentage: 0, message: 'ÏóÖÎ°úÎìú ÏãúÏûë...' };
    logQueueStatus();

    const { uploadToTeraBox } = await import('./teraboxUploader');
    // Use a dummy videoId since we don't have Supabase ID
    const dummyId = Date.now();
    const teraboxFileId = await uploadToTeraBox(compressedPath, dummyId);
    console.log(
      `‚úÖ [Job ${job.id}] Uploaded! TeraBox File ID: ${teraboxFileId}`
    );

    // Done
    job.status = 'done';
    job.teraboxFileId = teraboxFileId;
    job.progress = { percentage: 100, message: 'ÏôÑÎ£å!' };
    job.completedAt = Date.now();
    logQueueStatus();

    // Cleanup temp files
    console.log(`üßπ [Job ${job.id}] Cleaning up temp files...`);
    const fs = await import('fs/promises');
    await fs.unlink(downloadPath).catch(() => {});
    await fs.unlink(compressedPath).catch(() => {});
    console.log(`‚úÖ [Job ${job.id}] Cleanup done`);

    const duration = ((job.completedAt - job.startedAt!) / 1000 / 60).toFixed(
      1
    );
    console.log(
      `\nüéâ [Job ${job.id}] All steps completed in ${duration} minutes!`
    );
    console.log(`üì¶ [Job ${job.id}] TeraBox File ID: ${teraboxFileId}`);
  } catch (e) {
    console.error(`‚ùå [Job ${job.id}] Error during processing:`, e);
    job.status = 'error';
    job.error = String(e);
    job.completedAt = Date.now();
    throw e;
  }
}
